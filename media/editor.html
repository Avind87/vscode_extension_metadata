<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Vault 2.1 Metadata Prep App</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            font-family: var(--vscode-font-family);
            padding: 20px;
            color: var(--vscode-foreground);
            background-color: var(--vscode-editor-background);
            margin: 0;
        }

        .header {
            margin-bottom: 20px;
            border-bottom: 1px solid var(--vscode-panel-border);
            padding-bottom: 15px;
        }

        .header h1 {
            margin: 0 0 10px 0;
            font-size: 24px;
        }

        .header p {
            margin: 5px 0;
            color: var(--vscode-descriptionForeground);
            font-size: 12px;
        }

        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            padding: 8px 16px;
            background-color: var(--vscode-button-background);
            color: var(--vscode-button-foreground);
            border: none;
            cursor: pointer;
            font-size: 13px;
        }

        button:hover {
            background-color: var(--vscode-button-hoverBackground);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button.secondary {
            background-color: var(--vscode-button-secondaryBackground);
            color: var(--vscode-button-secondaryForeground);
        }

        button.secondary:hover {
            background-color: var(--vscode-button-secondaryHoverBackground);
        }

        .table-navigation {
            margin-bottom: 20px;
            padding: 15px;
            background-color: var(--vscode-editorWidget-background);
            border: 1px solid var(--vscode-editorWidget-border);
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .table-navigation select {
            flex: 1;
            min-width: 200px;
        }

        .table-section {
            margin-bottom: 30px;
            display: none;
        }

        .table-section.active {
            display: block;
        }

        .table-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding: 10px;
            background-color: var(--vscode-list-activeSelectionBackground);
            border-radius: 4px;
        }

        .table-header h2 {
            margin: 0;
            font-size: 18px;
        }

        .business-concept-selector {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            padding: 10px;
            background-color: var(--vscode-editorWidget-background);
            border: 1px solid var(--vscode-editorWidget-border);
            border-radius: 4px;
        }

        .business-concept-selector label {
            font-weight: 500;
            margin-right: 5px;
        }

        .hashkey-management,
        .link-management {
            margin-bottom: 15px;
            padding: 10px;
            background-color: var(--vscode-editorWidget-background);
            border: 1px solid var(--vscode-editorWidget-border);
            border-radius: 4px;
        }

        .hashkey-list {
            margin-top: 10px;
        }

        .hashkey-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            padding: 8px;
            background-color: var(--vscode-editor-background);
            border: 1px solid var(--vscode-panel-border);
            border-radius: 4px;
            cursor: move;
        }

        .hashkey-item.dragging {
            opacity: 0.5;
        }

        .hashkey-item .drag-handle {
            cursor: move;
            color: var(--vscode-descriptionForeground);
            font-size: 18px;
            user-select: none;
        }

        .hashkey-item .move-buttons {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .hashkey-item .move-buttons button {
            padding: 2px 6px;
            font-size: 10px;
            line-height: 1;
        }

        .hashkey-item input[type="text"] {
            flex: 1;
            min-width: 200px;
        }

        .hashkey-item .column-list {
            flex: 2;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .hashkey-item.link-hashkey {
            border-left: 3px solid var(--vscode-textLink-foreground);
        }

        .column-tag {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 4px 8px;
            background-color: var(--vscode-button-secondaryBackground);
            border-radius: 3px;
            font-size: 12px;
        }

        .column-tag .remove-btn {
            background: none;
            border: none;
            color: var(--vscode-foreground);
            cursor: pointer;
            padding: 0;
            font-size: 14px;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .technical-columns {
            margin-bottom: 15px;
            padding: 10px;
            background-color: var(--vscode-editorWidget-background);
            border: 1px solid var(--vscode-editorWidget-border);
            border-radius: 4px;
        }

        .technical-column-group {
            margin-bottom: 10px;
        }

        .technical-column-group label {
            font-weight: 500;
            margin-right: 10px;
            display: inline-block;
            min-width: 120px;
        }

        .hashdiff-management {
            margin-bottom: 15px;
            padding: 10px;
            background-color: var(--vscode-editorWidget-background);
            border: 1px solid var(--vscode-editorWidget-border);
            border-radius: 4px;
        }

        .hashdiff-item {
            margin-bottom: 15px;
            padding: 10px;
            background-color: var(--vscode-editor-background);
            border: 1px solid var(--vscode-panel-border);
            border-radius: 4px;
        }

        .hashdiff-mode-selector {
            margin-bottom: 10px;
        }

        .hashdiff-exclude-list, .hashdiff-include-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
        }

        .add-concept-input {
            display: inline-flex;
            gap: 5px;
            margin-left: 10px;
        }

        .add-concept-input input {
            width: 150px;
        }

        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal {
            background-color: var(--vscode-editor-background);
            padding: 20px;
            border-radius: 4px;
            min-width: 300px;
            max-width: 500px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background-color: var(--vscode-editor-background);
        }

        th, td {
            border: 1px solid var(--vscode-panel-border);
            padding: 8px 12px;
            text-align: left;
            font-size: 13px;
        }

        th {
            background-color: var(--vscode-editor-selectionBackground);
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        tr:nth-child(even) {
            background-color: var(--vscode-list-hoverBackground);
        }

        tr:hover {
            background-color: var(--vscode-list-activeSelectionBackground);
        }

        .column-name {
            font-weight: 500;
            font-family: var(--vscode-editor-font-family);
        }

        .contained-in-hash {
            font-family: var(--vscode-editor-font-family);
            font-size: 12px;
            color: var(--vscode-textLink-foreground);
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: var(--vscode-descriptionForeground);
        }

        .error {
            padding: 15px;
            background-color: var(--vscode-inputValidation-errorBackground);
            border: 1px solid var(--vscode-inputValidation-errorBorder);
            border-radius: 4px;
            color: var(--vscode-errorForeground);
            margin: 20px 0;
        }

        select, input[type="text"] {
            padding: 6px 10px;
            background-color: var(--vscode-input-background);
            color: var(--vscode-input-foreground);
            border: 1px solid var(--vscode-input-border);
            border-radius: 2px;
            font-size: 13px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Data Vault 2.1 Metadata Prep App</h1>
        <p id="db-path">Database: Loading...</p>
    </div>
    
    <div class="controls">
        <button id="load-btn" onclick="loadMetadata()">Load Metadata</button>
        <button id="save-btn" onclick="saveMetadata()" disabled>Save Metadata</button>
        <button id="export-btn" onclick="exportCSV()" disabled class="secondary">Export to CSV</button>
    </div>

    <div id="error-container"></div>

    <div id="table-navigation" style="display: none;" class="table-navigation">
        <label>Navigate to table:</label>
        <select id="table-selector" onchange="navigateToTable(this.value)">
            <option value="">-- Select Table --</option>
        </select>
        <button onclick="sortHashkeysAlphabetically()" style="padding: 4px 8px; font-size: 11px;">Sort Hashkeys A-Z</button>
        <button onclick="compareHashkeysWithOtherTables()" style="padding: 4px 8px; font-size: 11px;">Compare Hashkeys</button>
        <button onclick="showGlobalHashkeyView()" style="padding: 4px 8px; font-size: 11px;">Global Hashkey View</button>
    </div>

    <div id="global-hashkey-view" style="display: none; margin-bottom: 20px; padding: 15px; background-color: var(--vscode-editorWidget-background); border: 1px solid var(--vscode-editorWidget-border); border-radius: 4px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <h3 style="margin: 0;">Global Hashkey View</h3>
            <button onclick="hideGlobalHashkeyView()" style="padding: 4px 8px; font-size: 11px;">Close</button>
        </div>
        <div id="global-hashkey-content"></div>
    </div>

    <div id="content">
        <div class="loading">Click "Load Metadata" to start</div>
    </div>

    <script>
        const vscode = acquireVsCodeApi();
        let currentMetadata = null;
        let businessConcepts = ['Customer', 'Order', 'Product', 'Supplier', 'Employee', 'Location'];
        let allBusinessKeyGroups = {}; // tableId -> array of business key groups
        let allHashkeys = {}; // tableId -> set of hashkey names
        let recordSourceColumns = {}; // tableId -> column name
        let loadDateColumns = {}; // tableId -> column name
        let hashdiffGroups = {}; // tableId -> array of hashdiff groups
        let currentTableId = null;
        let draggedHashkeyIndex = null;
        let newConceptInputs = {}; // tableId -> input element for new concept

        function updateDbPath(path) {
            document.getElementById('db-path').textContent = `Database: ${path}`;
        }

        function exportNewFormatCSV() {
            console.log('exportNewFormatCSV function called');
            if (!currentMetadata || !currentMetadata.length) {
                alert('No metadata available. Please load metadata first.');
                return;
            }
            try {
                const metadata = collectMetadata();
                console.log('Metadata collected, sending message');
                vscode.postMessage({ command: 'exportNewFormatCSV', data: metadata });
            } catch (error) {
                console.error('Error in exportNewFormatCSV:', error);
                alert('Error exporting CSV: ' + (error.message || error));
            }
        }

        function browseMetadataInDuckDB() {
            console.log('browseMetadataInDuckDB function called');
            if (!currentMetadata || !currentMetadata.length) {
                alert('No metadata available. Please load metadata first.');
                return;
            }
            try {
                const metadata = collectMetadata();
                console.log('Metadata collected, sending message');
                vscode.postMessage({ command: 'browseMetadataInDuckDB' });
            } catch (error) {
                console.error('Error in browseMetadataInDuckDB:', error);
                alert('Error browsing in DuckDB: ' + (error.message || error));
            }
        }

        function handleExportNewClick(e) {
            e.preventDefault();
            e.stopPropagation();
            console.log('Export new button clicked via event listener');
            exportNewFormatCSV();
        }

        function handleBrowseDBClick(e) {
            e.preventDefault();
            e.stopPropagation();
            console.log('Browse DB button clicked via event listener');
            browseMetadataInDuckDB();
        }

        function loadMetadata() {
            document.getElementById('load-btn').disabled = true;
            document.getElementById('content').innerHTML = '<div class="loading">Loading metadata...</div>';
            vscode.postMessage({ command: 'loadMetadata' });
        }

        function saveMetadata() {
            try {
                const metadata = collectMetadata();
                console.log('Saving metadata:', JSON.stringify(metadata, null, 2));
                vscode.postMessage({ command: 'saveMetadata', data: metadata });
            } catch (error) {
                console.error('Error in saveMetadata:', error);
                alert('Error collecting metadata: ' + error.message);
            }
        }

        function exportCSV() {
            const metadata = collectMetadata();
            vscode.postMessage({ command: 'exportCSV', data: metadata });
        }


        function navigateToTable(tableId) {
            if (!tableId) return;
            
            // Hide all tables
            document.querySelectorAll('.table-section').forEach(section => {
                section.classList.remove('active');
            });
            
            // Show selected table
            const targetSection = document.querySelector(`[data-table-id="${tableId}"]`);
            if (targetSection) {
                targetSection.classList.add('active');
                currentTableId = tableId;
                targetSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }

        function getAllHashkeys() {
            const hashkeys = new Set();
            Object.values(allBusinessKeyGroups).forEach(groups => {
                groups.forEach(group => {
                    if (!group.isLink) {
                        hashkeys.add(group.hashkeyName);
                    }
                });
            });
            return Array.from(hashkeys).sort();
        }

        function sortHashkeysAlphabetically() {
            if (!currentTableId) return;
            const groups = allBusinessKeyGroups[currentTableId] || [];
            groups.sort((a, b) => a.hashkeyName.localeCompare(b.hashkeyName));
            groups.forEach((group, idx) => {
                group.order = idx + 1;
            });
            renderHashkeyManagement(currentTableId);
            updateColumnDisplay(currentTableId);
        }

        function compareHashkeysWithOtherTables() {
            if (!currentTableId) return;
            const currentHashkeys = (allBusinessKeyGroups[currentTableId] || [])
                .filter(g => !g.isLink)
                .map(g => g.hashkeyName)
                .sort();
            
            const otherHashkeys = {};
            Object.keys(allBusinessKeyGroups).forEach(tableId => {
                if (tableId !== currentTableId) {
                    const hashkeys = (allBusinessKeyGroups[tableId] || [])
                        .filter(g => !g.isLink)
                        .map(g => g.hashkeyName)
                        .sort();
                    if (hashkeys.length > 0) {
                        otherHashkeys[tableId] = hashkeys;
                    }
                }
            });

            let message = `Current table hashkeys:\n${currentHashkeys.join(', ')}\n\n`;
            message += `Hashkeys in other tables:\n`;
            Object.keys(otherHashkeys).forEach(tableId => {
                message += `\n${tableId}:\n  ${otherHashkeys[tableId].join(', ')}\n`;
            });

            alert(message);
        }

        function handleBusinessConceptChange(selectElement, tableId) {
            const value = selectElement.value;
            if (value === '__ADD_NEW__') {
                // Show input field
                const container = selectElement.closest('.business-concept-selector');
                let inputContainer = container.querySelector('.new-concept-input-container');
                if (!inputContainer) {
                    inputContainer = document.createElement('div');
                    inputContainer.className = 'new-concept-input-container';
                    inputContainer.style.display = 'flex';
                    inputContainer.style.gap = '5px';
                    inputContainer.style.marginLeft = '10px';
                    inputContainer.innerHTML = `
                        <input type="text" placeholder="Enter new concept name..." id="new-concept-input-${tableId}" style="width: 200px;">
                        <button onclick="addNewBusinessConcept('${tableId}')" style="padding: 4px 8px; font-size: 11px;">Add</button>
                        <button onclick="cancelAddConcept('${tableId}')" style="padding: 4px 8px; font-size: 11px;">Cancel</button>
                    `;
                    container.appendChild(inputContainer);
                }
                inputContainer.style.display = 'flex';
                document.getElementById(`new-concept-input-${tableId}`).focus();
            } else {
                // Hide input field if visible
                const container = selectElement.closest('.business-concept-selector');
                const inputContainer = container.querySelector('.new-concept-input-container');
                if (inputContainer) {
                    inputContainer.style.display = 'none';
                }
            }
        }

        function addNewBusinessConcept(tableId) {
            const input = document.getElementById(`new-concept-input-${tableId}`);
            const concept = input ? input.value.trim() : '';
            if (concept && !businessConcepts.includes(concept)) {
                businessConcepts.push(concept);
                businessConcepts.sort();
                refreshAllConceptSelectors();
                
                // Set the newly added concept as selected
                const select = document.querySelector(`[data-table-id="${tableId}"] .business-concept-select`);
                if (select) {
                    select.value = concept;
                }
                
                // Hide input field
                cancelAddConcept(tableId);
            }
        }

        function cancelAddConcept(tableId) {
            const container = document.querySelector(`[data-table-id="${tableId}"] .business-concept-selector`);
            const inputContainer = container ? container.querySelector('.new-concept-input-container') : null;
            if (inputContainer) {
                inputContainer.style.display = 'none';
                const input = inputContainer.querySelector('input');
                if (input) input.value = '';
            }
            // Reset dropdown
            const select = document.querySelector(`[data-table-id="${tableId}"] .business-concept-select`);
            if (select) {
                select.value = '';
            }
        }

        function handleHashkeyConceptChange(selectElement, tableId, hashkeyIndex) {
            const value = selectElement.value;
            if (value === '__ADD_NEW__') {
                // Show input field
                const inputContainer = document.getElementById(`hashkey-new-concept-${tableId}-${hashkeyIndex}`);
                if (inputContainer) {
                    inputContainer.style.display = 'flex';
                    document.getElementById(`hashkey-new-concept-input-${tableId}-${hashkeyIndex}`).focus();
                }
            } else if (value) {
                // Update hashkey business concept
                updateHashkeyBusinessConcept(tableId, hashkeyIndex, value);
                // Hide input field if visible
                const inputContainer = document.getElementById(`hashkey-new-concept-${tableId}-${hashkeyIndex}`);
                if (inputContainer) {
                    inputContainer.style.display = 'none';
                }
            }
        }

        function addNewHashkeyConcept(tableId, hashkeyIndex) {
            const input = document.getElementById(`hashkey-new-concept-input-${tableId}-${hashkeyIndex}`);
            const concept = input ? input.value.trim() : '';
            if (concept && !businessConcepts.includes(concept)) {
                businessConcepts.push(concept);
                businessConcepts.sort();
                refreshAllConceptSelectors();
                
                // Set the newly added concept and update hashkey
                updateHashkeyBusinessConcept(tableId, hashkeyIndex, concept);
                
                // Hide input field
                const inputContainer = document.getElementById(`hashkey-new-concept-${tableId}-${hashkeyIndex}`);
                if (inputContainer) {
                    inputContainer.style.display = 'none';
                    if (input) input.value = '';
                }
                
                // Update the select to show the new concept
                const select = document.querySelector(`#hashkey-new-concept-${tableId}-${hashkeyIndex}`)?.previousElementSibling;
                if (select && select.tagName === 'SELECT') {
                    select.value = concept;
                }
            }
        }

        function cancelAddHashkeyConcept(tableId, hashkeyIndex) {
            const inputContainer = document.getElementById(`hashkey-new-concept-${tableId}-${hashkeyIndex}`);
            if (inputContainer) {
                inputContainer.style.display = 'none';
                const input = inputContainer.querySelector('input');
                if (input) input.value = '';
            }
            // Reset dropdown
            const select = document.querySelector(`#hashkey-new-concept-${tableId}-${hashkeyIndex}`)?.previousElementSibling;
            if (select && select.tagName === 'SELECT') {
                select.value = '';
            }
        }

        function refreshAllConceptSelectors() {
            document.querySelectorAll('.business-concept-select, .hashkey-concept-select').forEach(select => {
                const currentValue = select.value;
                const isBusinessConcept = select.classList.contains('business-concept-select');
                let options = '<option value="">-- Select Concept --</option>';
                if (isBusinessConcept) {
                    options += '<option value="__ADD_NEW__">-- Add New Concept --</option>';
                }
                options += businessConcepts.map(c => `<option value="${c}">${c}</option>`).join('');
                select.innerHTML = options;
                if (currentValue && currentValue !== '__ADD_NEW__') {
                    select.value = currentValue;
                }
            });
        }

        function addHashkeyGroup(tableId, isLink = false) {
            if (!allBusinessKeyGroups[tableId]) {
                allBusinessKeyGroups[tableId] = [];
            }
            const groups = allBusinessKeyGroups[tableId];
            const newGroup = {
                hashkeyName: '', // Will be auto-generated from business concept
                businessConcept: '', // Business concept for this hashkey
                columns: [],
                order: groups.length + 1,
                isLink: isLink,
                referencedHashkeys: isLink ? [] : undefined
            };
            groups.push(newGroup);
            if (isLink) {
                renderLinkManagement(tableId);
            } else {
                renderHashkeyManagement(tableId);
            }
            updateColumnDisplay(tableId);
        }

        function updateHashkeyBusinessConcept(tableId, index, concept) {
            if (allBusinessKeyGroups[tableId] && allBusinessKeyGroups[tableId][index]) {
                const group = allBusinessKeyGroups[tableId][index];
                group.businessConcept = concept;
                // Auto-generate hashkey name: hk_{concept}_h
                if (concept) {
                    const conceptClean = concept.toLowerCase().replace(/[^a-z0-9]/g, '_');
                    group.hashkeyName = `hk_${conceptClean}_h`;
                } else {
                    group.hashkeyName = '';
                }
                renderHashkeyManagement(tableId);
                updateColumnDisplay(tableId);
            }
        }

        function removeHashkeyGroup(tableId, index) {
            if (allBusinessKeyGroups[tableId]) {
                allBusinessKeyGroups[tableId].splice(index, 1);
                allBusinessKeyGroups[tableId].forEach((group, idx) => {
                    group.order = idx + 1;
                });
                renderHashkeyManagement(tableId);
                updateColumnDisplay(tableId);
            }
        }

        function moveHashkeyUp(tableId, index) {
            if (index > 0 && allBusinessKeyGroups[tableId]) {
                const groups = allBusinessKeyGroups[tableId];
                [groups[index - 1], groups[index]] = [groups[index], groups[index - 1]];
                groups.forEach((group, idx) => {
                    group.order = idx + 1;
                });
                renderHashkeyManagement(tableId);
                updateColumnDisplay(tableId);
            }
        }

        function moveHashkeyDown(tableId, index) {
            if (allBusinessKeyGroups[tableId] && index < allBusinessKeyGroups[tableId].length - 1) {
                const groups = allBusinessKeyGroups[tableId];
                [groups[index], groups[index + 1]] = [groups[index + 1], groups[index]];
                groups.forEach((group, idx) => {
                    group.order = idx + 1;
                });
                renderHashkeyManagement(tableId);
                updateColumnDisplay(tableId);
            }
        }

        // Hashkey name is now auto-generated, so this function is not needed for regular hashkeys
        // But we keep it for link hashkeys which can have custom names
        function updateHashkeyName(tableId, index, newName) {
            if (allBusinessKeyGroups[tableId] && allBusinessKeyGroups[tableId][index]) {
                const group = allBusinessKeyGroups[tableId][index];
                // Only allow manual editing for link hashkeys
                if (group.isLink) {
                    group.hashkeyName = newName;
                    updateColumnDisplay(tableId);
                }
            }
        }

        function addColumnToHashkeyGroup(tableId, groupIndex, columnName) {
            if (allBusinessKeyGroups[tableId] && allBusinessKeyGroups[tableId][groupIndex]) {
                const group = allBusinessKeyGroups[tableId][groupIndex];
                if (!group.columns.includes(columnName)) {
                    group.columns.push(columnName);
                    renderHashkeyManagement(tableId);
                    updateColumnDisplay(tableId);
                }
            }
        }

        function removeColumnFromHashkeyGroup(tableId, groupIndex, columnName) {
            if (allBusinessKeyGroups[tableId] && allBusinessKeyGroups[tableId][groupIndex]) {
                const group = allBusinessKeyGroups[tableId][groupIndex];
                const index = group.columns.indexOf(columnName);
                if (index > -1) {
                    group.columns.splice(index, 1);
                    renderHashkeyManagement(tableId);
                    updateColumnDisplay(tableId);
                }
            }
        }

        function addReferencedHashkey(tableId, groupIndex, hashkeyName) {
            if (allBusinessKeyGroups[tableId] && allBusinessKeyGroups[tableId][groupIndex]) {
                const group = allBusinessKeyGroups[tableId][groupIndex];
                if (!group.referencedHashkeys) {
                    group.referencedHashkeys = [];
                }
                if (!group.referencedHashkeys.includes(hashkeyName)) {
                    group.referencedHashkeys.push(hashkeyName);
                    // Auto-suggest link name if we have 2+ hashkeys
                    if (group.referencedHashkeys.length >= 2 && !group.hashkeyName) {
                        group.hashkeyName = group.referencedHashkeys
                            .map(hk => hk.replace(/^hk_/, '').replace(/_h$/, ''))
                            .join('_');
                    }
                    renderLinkManagement(tableId);
                }
            }
        }

        function removeReferencedHashkey(tableId, groupIndex, hashkeyName) {
            if (allBusinessKeyGroups[tableId] && allBusinessKeyGroups[tableId][groupIndex]) {
                const group = allBusinessKeyGroups[tableId][groupIndex];
                if (group.referencedHashkeys) {
                    const index = group.referencedHashkeys.indexOf(hashkeyName);
                    if (index > -1) {
                        group.referencedHashkeys.splice(index, 1);
                        // Update suggested name
                        if (group.referencedHashkeys.length >= 2 && !group.hashkeyName) {
                            group.hashkeyName = group.referencedHashkeys
                                .map(hk => hk.replace(/^hk_/, '').replace(/_h$/, ''))
                                .join('_');
                        }
                        renderLinkManagement(tableId);
                    }
                }
            }
        }

        function renderHashkeyManagement(tableId) {
            const container = document.querySelector(`[data-table-id="${tableId}"] .hashkey-management`);
            if (!container) return;

            const groups = (allBusinessKeyGroups[tableId] || []).sort((a, b) => a.order - b.order);
            const tableMeta = currentMetadata.find(m => `${m.schema}_${m.table}` === tableId);
            const availableColumns = tableMeta ? tableMeta.columns.map(c => c.column_name) : [];
            const allHashkeysList = getAllHashkeys();

            let html = '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; flex-wrap: wrap; gap: 10px;">';
            html += '<strong>Hubs / Business Concepts</strong>';
            html += '<div style="display: flex; gap: 5px;">';
            html += `<button onclick="addHashkeyGroup('${tableId}', false)" style="padding: 4px 8px; font-size: 11px;">+ Add Hub</button>`;
            html += '</div>';
            html += '</div>';

            html += '<div class="hashkey-list">';
            const hubGroups = groups.filter(g => !g.isLink);
            hubGroups.forEach((group, hubIndex) => {
                const isLink = false;
                // Find the actual index in the full groups array
                const actualIndex = groups.findIndex(g => g === group);
                html += `<div class="hashkey-item" draggable="true" 
                         ondragstart="handleHashkeyDragStart(event, ${actualIndex})" 
                         ondragover="handleHashkeyDragOver(event)" 
                         ondragleave="handleHashkeyDragLeave(event)"
                         ondrop="handleHashkeyDrop(event, '${tableId}', ${actualIndex})"
                         ondragend="handleHashkeyDragEnd(event)">`;
                
                html += '<div class="move-buttons">';
                html += `<button onclick="moveHashkeyUp('${tableId}', ${actualIndex})" ${hubIndex === 0 ? 'disabled' : ''}>↑</button>`;
                html += `<button onclick="moveHashkeyDown('${tableId}', ${actualIndex})" ${hubIndex === hubGroups.length - 1 ? 'disabled' : ''}>↓</button>`;
                html += '</div>';

                html += '<span class="drag-handle">☰</span>';

                if (isLink) {
                    html += `<input type="text" value="${group.hashkeyName}" placeholder="Link hashkey name" 
                             onchange="updateHashkeyName('${tableId}', ${actualIndex}, this.value)" 
                             style="min-width: 200px;">`;
                    html += '<span>→</span>';
                    html += '<div class="column-list">';
                    (group.referencedHashkeys || []).forEach(hk => {
                        html += `<span class="column-tag">${hk} <button class="remove-btn" onclick="removeReferencedHashkey('${tableId}', ${actualIndex}, '${hk}')">×</button></span>`;
                    });
                    html += `<select onchange="if(this.value) { addReferencedHashkey('${tableId}', ${actualIndex}, this.value); this.value=''; }" style="min-width: 150px;">
                             <option value="">Add hashkey...</option>`;
                    allHashkeysList.forEach(hk => {
                        if (!group.referencedHashkeys || !group.referencedHashkeys.includes(hk)) {
                            html += `<option value="${hk}">${hk}</option>`;
                        }
                    });
                    html += '</select>';
                } else {
                    // Regular hashkey: use business concept dropdown
                    html += '<div style="display: flex; align-items: center; gap: 10px; flex: 1;">';
                    html += `<select class="hashkey-concept-select" onchange="handleHashkeyConceptChange(this, '${tableId}', ${actualIndex})" style="min-width: 200px;">
                             <option value="">-- Select Business Concept --</option>
                             <option value="__ADD_NEW__">-- Add New Concept --</option>`;
                    businessConcepts.forEach(c => {
                        html += `<option value="${c}" ${group.businessConcept === c ? 'selected' : ''}>${c}</option>`;
                    });
                    html += '</select>';
                    html += `<div class="new-concept-input-container" id="hashkey-new-concept-${tableId}-${actualIndex}" style="display: none; gap: 5px;">
                             <input type="text" placeholder="Enter new concept name..." id="hashkey-new-concept-input-${tableId}-${actualIndex}" style="width: 150px;">
                             <button onclick="addNewHashkeyConcept('${tableId}', ${actualIndex})" style="padding: 4px 8px; font-size: 11px;">Add</button>
                             <button onclick="cancelAddHashkeyConcept('${tableId}', ${actualIndex})" style="padding: 4px 8px; font-size: 11px;">Cancel</button>
                             </div>`;
                    html += '</div>';
                    html += `<div style="color: var(--vscode-descriptionForeground); font-size: 11px; margin-left: 10px;">${group.hashkeyName || '(name will be auto-generated)'}</div>`;
                    html += '<span>→</span>';
                    html += '<div class="column-list">';
                    group.columns.forEach(col => {
                        html += `<span class="column-tag">${col} <button class="remove-btn" onclick="removeColumnFromHashkeyGroup('${tableId}', ${actualIndex}, '${col}')">×</button></span>`;
                    });
                    html += `<select onchange="if(this.value) { addColumnToHashkeyGroup('${tableId}', ${actualIndex}, this.value); this.value=''; }" style="min-width: 150px;">
                             <option value="">Add column...</option>`;
                    availableColumns.forEach(col => {
                        if (!group.columns.includes(col)) {
                            html += `<option value="${col}">${col}</option>`;
                        }
                    });
                    html += '</select>';
                    html += '</div>';
                }
                html += `<button onclick="removeHashkeyGroup('${tableId}', ${actualIndex})" style="padding: 4px 8px; font-size: 11px; margin-left: auto;">Remove</button>`;
                html += '</div></div>';
            });
            html += '</div>';

            container.innerHTML = html;
            renderLinkManagement(tableId);
        }

        function renderLinkManagement(tableId) {
            const container = document.querySelector(`[data-table-id="${tableId}"] .link-management`);
            if (!container) return;

            const groups = (allBusinessKeyGroups[tableId] || []).sort((a, b) => a.order - b.order);
            const linkGroups = groups.filter(g => g.isLink);
            const allHashkeysList = getAllHashkeys();

            let html = '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; flex-wrap: wrap; gap: 10px;">';
            html += '<strong>Links / Relationships</strong>';
            html += '<div style="display: flex; gap: 5px;">';
            html += `<button onclick="addHashkeyGroup('${tableId}', true)" style="padding: 4px 8px; font-size: 11px;">+ Add Link</button>`;
            html += '</div>';
            html += '</div>';

            html += '<div class="hashkey-list">';
            linkGroups.forEach((group, linkIndex) => {
                const actualIndex = groups.findIndex(g => g === group);
                html += `<div class="hashkey-item link-hashkey" draggable="true" 
                         ondragstart="handleHashkeyDragStart(event, ${actualIndex})" 
                         ondragover="handleHashkeyDragOver(event)" 
                         ondragleave="handleHashkeyDragLeave(event)"
                         ondrop="handleHashkeyDrop(event, '${tableId}', ${actualIndex})"
                         ondragend="handleHashkeyDragEnd(event)">`;
                
                html += '<div class="move-buttons">';
                html += `<button onclick="moveHashkeyUp('${tableId}', ${actualIndex})" ${linkIndex === 0 ? 'disabled' : ''}>↑</button>`;
                html += `<button onclick="moveHashkeyDown('${tableId}', ${actualIndex})" ${linkIndex === linkGroups.length - 1 ? 'disabled' : ''}>↓</button>`;
                html += '</div>';

                html += '<span class="drag-handle">☰</span>';

                // First, select hub hashkeys
                html += '<div style="display: flex; align-items: center; gap: 10px; flex: 1; flex-wrap: wrap;">';
                html += '<div class="column-list">';
                (group.referencedHashkeys || []).forEach(hk => {
                    html += `<span class="column-tag">${hk} <button class="remove-btn" onclick="removeReferencedHashkey('${tableId}', ${actualIndex}, '${hk}')">×</button></span>`;
                });
                html += `<select onchange="if(this.value) { addReferencedHashkey('${tableId}', ${actualIndex}, this.value); this.value=''; }" style="min-width: 150px;">
                         <option value="">Select Hub Hashkeys...</option>`;
                allHashkeysList.forEach(hk => {
                    if (!group.referencedHashkeys || !group.referencedHashkeys.includes(hk)) {
                        html += `<option value="${hk}">${hk}</option>`;
                    }
                });
                html += '</select>';
                html += '</div>';

                // Then show suggested name (editable)
                const suggestedName = group.referencedHashkeys && group.referencedHashkeys.length >= 2 
                    ? group.referencedHashkeys.map(hk => hk.replace(/^hk_/, '').replace(/_h$/, '')).join('_')
                    : '';
                html += `<input type="text" value="${group.hashkeyName || suggestedName}" placeholder="Link name (auto-suggested)" 
                         onchange="updateHashkeyName('${tableId}', ${actualIndex}, this.value)" 
                         style="min-width: 200px;">`;
                html += '</div>';

                html += `<button onclick="removeHashkeyGroup('${tableId}', ${actualIndex})" style="padding: 4px 8px; font-size: 11px; margin-left: auto;">Remove</button>`;
                html += '</div>';
            });
            html += '</div>';

            container.innerHTML = html;
        }

        function handleHashkeyDragStart(event, index) {
            draggedHashkeyIndex = index;
            event.dataTransfer.effectAllowed = 'move';
            event.currentTarget.classList.add('dragging');
        }

        function handleHashkeyDragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
            const target = event.currentTarget;
            if (target && target !== event.target.closest('.hashkey-item')) {
                target.style.borderTop = '2px solid var(--vscode-focusBorder)';
            }
        }

        function handleHashkeyDragLeave(event) {
            event.currentTarget.style.borderTop = '';
        }

        function handleHashkeyDrop(event, tableId, dropIndex) {
            event.preventDefault();
            event.currentTarget.style.borderTop = '';
            
            if (draggedHashkeyIndex === null || draggedHashkeyIndex === dropIndex) {
                draggedHashkeyIndex = null;
                return;
            }
            
            const groups = allBusinessKeyGroups[tableId];
            if (!groups || draggedHashkeyIndex >= groups.length) {
                draggedHashkeyIndex = null;
                return;
            }
            
            const draggedGroup = groups[draggedHashkeyIndex];
            groups.splice(draggedHashkeyIndex, 1);
            
            // Adjust drop index if we removed an item before it
            const adjustedDropIndex = draggedHashkeyIndex < dropIndex ? dropIndex - 1 : dropIndex;
            groups.splice(adjustedDropIndex, 0, draggedGroup);
            
            groups.forEach((group, idx) => {
                group.order = idx + 1;
            });
            
            draggedHashkeyIndex = null;
            renderHashkeyManagement(tableId);
            updateColumnDisplay(tableId);
        }

        function handleHashkeyDragEnd(event) {
            event.currentTarget.classList.remove('dragging');
            draggedHashkeyIndex = null;
        }

        function showGlobalHashkeyView() {
            const view = document.getElementById('global-hashkey-view');
            const content = document.getElementById('global-hashkey-content');
            
            let html = '<table style="width: 100%;"><thead><tr><th>Hashkey Name</th><th>Business Concept</th><th>Table</th><th>Columns</th><th>Actions</th></tr></thead><tbody>';
            
            Object.keys(allBusinessKeyGroups).forEach(tableId => {
                const groups = allBusinessKeyGroups[tableId] || [];
                const tableMeta = currentMetadata.find(m => `${m.schema}_${m.table}` === tableId);
                const tableName = tableMeta ? `${tableMeta.schema}.${tableMeta.table}` : tableId;
                
                groups.filter(g => !g.isLink).forEach((group, index) => {
                    html += '<tr>';
                    html += `<td>${group.hashkeyName || '(not set)'}</td>`;
                    html += `<td>${group.businessConcept || '(not set)'}</td>`;
                    html += `<td>${tableName}</td>`;
                    html += `<td>${group.columns.join(', ') || '(no columns)'}</td>`;
                    html += `<td><button onclick="navigateToTable('${tableId}')" style="padding: 4px 8px; font-size: 11px;">Go to Table</button></td>`;
                    html += '</tr>';
                });
            });
            
            html += '</tbody></table>';
            content.innerHTML = html;
            view.style.display = 'block';
        }

        function hideGlobalHashkeyView() {
            document.getElementById('global-hashkey-view').style.display = 'none';
        }

        function setRecordSource(tableId, columnName) {
            recordSourceColumns[tableId] = columnName;
            updateColumnDisplay(tableId);
        }

        function setLoadDate(tableId, columnName) {
            loadDateColumns[tableId] = columnName;
            updateColumnDisplay(tableId);
        }

        function setHashdiffConcept(tableId, index, concept) {
            if (hashdiffGroups[tableId] && hashdiffGroups[tableId][index]) {
                const diff = hashdiffGroups[tableId][index];
                diff.concept = concept;
                
                // Auto-select the hashkey for this concept (there's only one per concept)
                if (concept) {
                    let foundHashkey = null;
                    Object.values(allBusinessKeyGroups).forEach((groups) => {
                        groups.forEach((group) => {
                            if (!group.isLink && group.businessConcept === concept && group.hashkeyName) {
                                foundHashkey = group.hashkeyName;
                            }
                        });
                    });
                    diff.hashkey = foundHashkey || '';
                    
                    // Auto-generate name based on concept and table
                    const tableMeta = currentMetadata.find(m => `${m.schema}_${m.table}` === tableId);
                    if (tableMeta) {
                        diff.name = generateHashdiffName(concept, tableMeta.table);
                    }
                } else {
                    diff.hashkey = '';
                }
                
                renderHashdiffManagement(tableId);
            }
        }

        function setHashdiffHashkey(tableId, index, hashkey) {
            if (hashdiffGroups[tableId] && hashdiffGroups[tableId][index]) {
                hashdiffGroups[tableId][index].hashkey = hashkey;
            }
        }

        function getColumnContainedIn(tableId, columnName) {
            // Check if in hashkey group
            const groups = allBusinessKeyGroups[tableId] || [];
            for (const group of groups) {
                if (group.columns.includes(columnName)) {
                    return group.hashkeyName;
                }
            }
            // Check if record source
            if (recordSourceColumns[tableId] === columnName) {
                return 'Record Source';
            }
            // Check if load date
            if (loadDateColumns[tableId] === columnName) {
                return 'Load Date';
            }
            // Check if in hashdiff
            const hashdiffName = getColumnHashdiff(tableId, columnName);
            if (hashdiffName) {
                return hashdiffName;
            }
            return '';
        }

        function generateHashdiffName(concept, table) {
            if (concept) {
                // Format: hd_<concept>_<table>_sat
                const conceptClean = concept.toLowerCase().replace(/[^a-z0-9]/g, '_');
                const tableClean = table.toLowerCase().replace(/[^a-z0-9]/g, '_');
                return `hd_${conceptClean}_${tableClean}_sat`;
            }
            // Fallback to old format if no concept
            const tableClean = table.toLowerCase().replace(/[^a-z0-9]/g, '_');
            return `hd_${tableClean}_sat`;
        }

        function getDefaultHashdiffColumns(tableMeta) {
            const businessKeyColumns = new Set();
            const tableId = `${tableMeta.schema}_${tableMeta.table}`;
            const bkGroups = allBusinessKeyGroups[tableId] || [];
            bkGroups.forEach(group => {
                group.columns.forEach(col => businessKeyColumns.add(col));
            });
            return tableMeta.columns.filter(col => {
                return !businessKeyColumns.has(col.column_name) &&
                       recordSourceColumns[tableId] !== col.column_name &&
                       loadDateColumns[tableId] !== col.column_name;
            }).map(col => col.column_name);
        }

        function addHashdiffGroup(tableId) {
            if (!hashdiffGroups[tableId]) {
                hashdiffGroups[tableId] = [];
            }
            const tableMeta = currentMetadata.find(m => `${m.schema}_${m.table}` === tableId);
            const defaultName = tableMeta ? generateHashdiffName('', tableMeta.table) : 'hd_table_sat';
            const newGroup = {
                name: defaultName,
                mode: 'select_all', // 'select_all' or 'select_explicit'
                excludedColumns: [],
                includedColumns: [],
                concept: '', // Business concept this hashdiff belongs to
                hashkey: '', // Hashkey this hashdiff belongs to
                order: hashdiffGroups[tableId].length + 1
            };
            hashdiffGroups[tableId].push(newGroup);
            renderHashdiffManagement(tableId);
            updateColumnDisplay(tableId);
        }

        function removeHashdiffGroup(tableId, index) {
            if (hashdiffGroups[tableId]) {
                hashdiffGroups[tableId].splice(index, 1);
                renderHashdiffManagement(tableId);
                updateColumnDisplay(tableId);
            }
        }

        function updateHashdiffName(tableId, index, newName) {
            if (hashdiffGroups[tableId] && hashdiffGroups[tableId][index]) {
                hashdiffGroups[tableId][index].name = newName;
                updateColumnDisplay(tableId);
            }
        }

        function setHashdiffMode(tableId, index, mode) {
            if (hashdiffGroups[tableId] && hashdiffGroups[tableId][index]) {
                hashdiffGroups[tableId][index].mode = mode;
                renderHashdiffManagement(tableId);
                updateColumnDisplay(tableId);
            }
        }

        function toggleHashdiffColumn(tableId, diffIndex, columnName, isExcluded) {
            if (!hashdiffGroups[tableId] || !hashdiffGroups[tableId][diffIndex]) return;
            const diff = hashdiffGroups[tableId][diffIndex];
            const array = isExcluded ? diff.excludedColumns : diff.includedColumns;
            const otherArray = isExcluded ? diff.includedColumns : diff.excludedColumns;
            const index = array.indexOf(columnName);
            if (index > -1) {
                array.splice(index, 1);
            } else {
                array.push(columnName);
                // Remove from other array if present
                const otherIndex = otherArray.indexOf(columnName);
                if (otherIndex > -1) {
                    otherArray.splice(otherIndex, 1);
                }
            }
            renderHashdiffManagement(tableId);
            updateColumnDisplay(tableId);
        }

        function renderHashdiffManagement(tableId) {
            const container = document.querySelector(`[data-table-id="${tableId}"] .hashdiff-management`);
            if (!container) return;

            const diffs = hashdiffGroups[tableId] || [];
            const tableMeta = currentMetadata.find(m => `${m.schema}_${m.table}` === tableId);
            const availableColumns = tableMeta ? tableMeta.columns.map(c => c.column_name) : [];
            // Default name will be generated when concept is selected
            const defaultName = 'hd_<concept>_<table>_sat';

            let html = '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">';
            html += '<strong>Satellites / Descriptive Data</strong>';
            html += `<button onclick="addHashdiffGroup('${tableId}')" style="padding: 4px 8px; font-size: 11px;">+ Add Satellite</button>`;
            html += '</div>';

            diffs.forEach((diff, index) => {
                html += '<div class="hashdiff-item">';
                
                // Concept selector - get all concepts from all hashkeys (must be selected first)
                html += '<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px; flex-wrap: wrap;">';
                html += '<label style="font-weight: bold;">Business Concept:</label>';
                const allConcepts = new Set();
                Object.values(allBusinessKeyGroups).forEach((groups) => {
                    groups.forEach((group) => {
                        if (group.businessConcept && !group.isLink) {
                            allConcepts.add(group.businessConcept);
                        }
                    });
                });
                const sortedConcepts = Array.from(allConcepts).sort();
                
                html += `<select onchange="setHashdiffConcept('${tableId}', ${index}, this.value)" style="min-width: 150px;" required>
                         <option value="">-- Select Concept First --</option>`;
                sortedConcepts.forEach(concept => {
                    html += `<option value="${concept}" ${diff.concept === concept ? 'selected' : ''}>${concept}</option>`;
                });
                html += '</select>';
                html += '</div>';
                
                // Hashkey is auto-selected based on concept (display only)
                if (diff.concept && diff.hashkey) {
                    html += '<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px; flex-wrap: wrap;">';
                    html += '<label style="font-weight: bold;">Hashkey:</label>';
                    html += `<span style="color: var(--vscode-descriptionForeground);">${diff.hashkey}</span>`;
                    html += '</div>';
                }
                
                // Satellite name (auto-generated when concept is selected, but editable)
                html += '<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px; flex-wrap: wrap;">';
                html += '<label style="font-weight: bold;">Satellite Name:</label>';
                const displayName = diff.name || (diff.concept && tableMeta ? generateHashdiffName(diff.concept, tableMeta.table) : defaultName);
                html += `<input type="text" value="${displayName}" placeholder="${defaultName}" 
                         onchange="updateHashdiffName('${tableId}', ${index}, this.value)" 
                         style="min-width: 250px;">`;
                html += '</div>';
                
                html += `<button onclick="removeHashdiffGroup('${tableId}', ${index})" style="padding: 4px 8px; font-size: 11px; margin-bottom: 10px;">Remove</button>`;
                html += '</div>';
                
                html += '<div class="hashdiff-mode-selector">';
                html += `<label><input type="radio" name="hashdiff-mode-${tableId}-${index}" value="select_all" 
                         ${diff.mode === 'select_all' ? 'checked' : ''} 
                         onchange="setHashdiffMode('${tableId}', ${index}, 'select_all')"> Select All (exclude specific)</label>`;
                html += `<label style="margin-left: 20px;"><input type="radio" name="hashdiff-mode-${tableId}-${index}" value="select_explicit" 
                         ${diff.mode === 'select_explicit' ? 'checked' : ''} 
                         onchange="setHashdiffMode('${tableId}', ${index}, 'select_explicit')"> Select Explicit Columns</label>`;
                html += '</div>';

                if (diff.mode === 'select_all') {
                    html += '<div style="margin-top: 10px;"><strong>Exclude columns:</strong></div>';
                    html += '<div class="hashdiff-exclude-list">';
                    diff.excludedColumns.forEach(col => {
                        html += `<span class="column-tag">${col} <button class="remove-btn" onclick="toggleHashdiffColumn('${tableId}', ${index}, '${col}', true)">×</button></span>`;
                    });
                    html += `<select onchange="if(this.value) { toggleHashdiffColumn('${tableId}', ${index}, this.value, true); this.value=''; }" style="min-width: 150px;">
                             <option value="">Add to exclude...</option>`;
                    availableColumns.forEach(col => {
                        if (!diff.excludedColumns.includes(col)) {
                            html += `<option value="${col}">${col}</option>`;
                        }
                    });
                    html += '</select>';
                    html += '</div>';
                } else {
                    html += '<div style="margin-top: 10px;"><strong>Include columns:</strong></div>';
                    html += '<div class="hashdiff-include-list">';
                    diff.includedColumns.forEach(col => {
                        html += `<span class="column-tag">${col} <button class="remove-btn" onclick="toggleHashdiffColumn('${tableId}', ${index}, '${col}', false)">×</button></span>`;
                    });
                    html += `<select onchange="if(this.value) { toggleHashdiffColumn('${tableId}', ${index}, this.value, false); this.value=''; }" style="min-width: 150px;">
                             <option value="">Add to include...</option>`;
                    availableColumns.forEach(col => {
                        if (!diff.includedColumns.includes(col)) {
                            html += `<option value="${col}">${col}</option>`;
                        }
                    });
                    html += '</select>';
                    html += '</div>';
                }
                html += '</div>';
            });

            container.innerHTML = html;
        }

        function getColumnHashdiff(tableId, columnName) {
            const diffs = hashdiffGroups[tableId] || [];
            for (const diff of diffs) {
                if (diff.mode === 'select_all') {
                    // Include if not in excluded list
                    if (!diff.excludedColumns.includes(columnName)) {
                        return diff.name;
                    }
                } else {
                    // Include if in included list
                    if (diff.includedColumns.includes(columnName)) {
                        return diff.name;
                    }
                }
            }
            return '';
        }

        function updateColumnDisplay(tableId) {
            const tableSection = document.querySelector(`[data-table-id="${tableId}"]`);
            if (!tableSection) return;
            
            const tbody = tableSection.querySelector('tbody');
            if (!tbody) return;

            const rows = tbody.querySelectorAll('tr');
            rows.forEach(row => {
                const columnName = row.dataset.column;
                const containedInCell = row.querySelector('.contained-in-hash');
                if (containedInCell) {
                    const containedIn = getColumnContainedIn(tableId, columnName);
                    containedInCell.textContent = containedIn || '';
                }
            });
        }

        function collectMetadata() {
            const tables = [];
            const tableSections = document.querySelectorAll('.table-section');
            
            tableSections.forEach(section => {
                const tableName = section.dataset.table;
                const schemaName = section.dataset.schema;
                const tableId = `${schemaName}_${tableName}`;
                const rows = section.querySelectorAll('tbody tr');
                
                const businessConcept = ''; // Business concept is now only at hashdiff level
                const businessKeyGroups = (allBusinessKeyGroups[tableId] || []).sort((a, b) => a.order - b.order);
                const hashdiffGroupsData = hashdiffGroups[tableId] || [];
                
                const columns = [];
                rows.forEach(row => {
                    const columnName = row.dataset.column;
                    const order = parseInt(row.querySelector('.order-input')?.value) || 0;
                    
                    let businessKeyGroup = '';
                    businessKeyGroups.forEach(group => {
                        if (group.columns.includes(columnName)) {
                            businessKeyGroup = group.hashkeyName;
                        }
                    });
                    
                    columns.push({
                        schema: schemaName,
                        table: tableName,
                        column: columnName,
                        order: order,
                        businessKeyGroup: businessKeyGroup,
                        isRecordSource: recordSourceColumns[tableId] === columnName,
                        isLoadDate: loadDateColumns[tableId] === columnName
                    });
                });
                
                columns.sort((a, b) => a.order - b.order);
                
                tables.push({
                    schema: schemaName,
                    table: tableName,
                    businessConcept: businessConcept,
                    businessKeyGroups: businessKeyGroups,
                    hashdiffGroups: hashdiffGroupsData,
                    columns: columns
                });
            });

            return {
                tables: tables,
                timestamp: new Date().toISOString()
            };
        }

        function displayMetadata(metadata) {
            currentMetadata = metadata;
            const container = document.getElementById('content');
            
            if (!metadata || metadata.length === 0) {
                container.innerHTML = '<div class="loading">No tables found in database</div>';
                return;
            }

            // Initialize business key groups for each table
            metadata.forEach(tableMeta => {
                const tableId = `${tableMeta.schema}_${tableMeta.table}`;
                if (!allBusinessKeyGroups[tableId]) {
                    allBusinessKeyGroups[tableId] = [];
                }
                if (!recordSourceColumns[tableId]) {
                    recordSourceColumns[tableId] = '';
                }
                if (!loadDateColumns[tableId]) {
                    loadDateColumns[tableId] = '';
                }
                if (!hashdiffGroups[tableId]) {
                    hashdiffGroups[tableId] = [];
                }
            });

            // Populate table navigation
            const tableSelector = document.getElementById('table-selector');
            tableSelector.innerHTML = '<option value="">-- Select Table --</option>' +
                metadata.map(m => {
                    const tableId = `${m.schema}_${m.table}`;
                    return `<option value="${tableId}">${m.schema}.${m.table}</option>`;
                }).join('');
            document.getElementById('table-navigation').style.display = 'flex';

            let html = '';
            
            metadata.forEach((tableMeta, metaIndex) => {
                const tableId = `${tableMeta.schema}_${tableMeta.table}`;
                const isFirst = metaIndex === 0;
                
                html += `
                    <div class="table-section ${isFirst ? 'active' : ''}" data-schema="${tableMeta.schema}" data-table="${tableMeta.table}" data-table-id="${tableId}">
                        <div class="table-header">
                            <h2>${tableMeta.schema}.${tableMeta.table}</h2>
                            <span>${tableMeta.columns.length} columns</span>
                        </div>
                        <div class="hashkey-management"></div>
                        <div class="link-management"></div>
                        <div class="hashdiff-management"></div>
                        <div class="technical-columns">
                            <div class="technical-column-group">
                                <label>Record Source:</label>
                                <select onchange="setRecordSource('${tableId}', this.value)">
                                    <option value="">-- Select Column --</option>
                                    ${tableMeta.columns.map(c => 
                                        `<option value="${c.column_name}" ${recordSourceColumns[tableId] === c.column_name ? 'selected' : ''}>${c.column_name}</option>`
                                    ).join('')}
                                </select>
                            </div>
                            <div class="technical-column-group">
                                <label>Load Date:</label>
                                <select onchange="setLoadDate('${tableId}', this.value)">
                                    <option value="">-- Select Column --</option>
                                    ${tableMeta.columns.map(c => 
                                        `<option value="${c.column_name}" ${loadDateColumns[tableId] === c.column_name ? 'selected' : ''}>${c.column_name}</option>`
                                    ).join('')}
                                </select>
                            </div>
                        </div>
                        <table>
                            <thead>
                                <tr>
                                    <th style="width: 50px;">Order</th>
                                    <th>Column Name</th>
                                    <th>Data Type</th>
                                    <th>Contained in Hash / Technical Column</th>
                                </tr>
                            </thead>
                            <tbody>
                `;

                tableMeta.columns.forEach((col, index) => {
                    const containedIn = getColumnContainedIn(tableId, col.column_name);
                    
                    html += `
                        <tr data-column="${col.column_name}">
                            <td>
                                <input type="number" class="order-input" value="${col.ordinal_position}" min="1" readonly>
                            </td>
                            <td class="column-name">${col.column_name}</td>
                            <td>${col.data_type}</td>
                            <td class="contained-in-hash">${containedIn || ''}</td>
                        </tr>
                    `;
                });

                html += `
                            </tbody>
                        </table>
                    </div>
                `;
            });

            container.innerHTML = html;
            
            // Render hashkey, link, and hashdiff management for each table
            metadata.forEach(tableMeta => {
                const tableId = `${tableMeta.schema}_${tableMeta.table}`;
                renderHashkeyManagement(tableId);
                renderLinkManagement(tableId);
                renderHashdiffManagement(tableId);
                updateColumnDisplay(tableId);
            });
            
            if (metadata.length > 0) {
                currentTableId = `${metadata[0].schema}_${metadata[0].table}`;
            }
            
            document.getElementById('save-btn').disabled = false;
            document.getElementById('export-btn').disabled = false;
        }

        function updateStatus(element) {
            // Visual feedback placeholder
        }

        function showError(message) {
            const container = document.getElementById('error-container');
            container.innerHTML = `<div class="error">${message}</div>`;
        }

        function clearError() {
            document.getElementById('error-container').innerHTML = '';
        }

        // Handle messages from extension
        window.addEventListener('message', event => {
            const message = event.data;
            
            switch (message.command) {
                case 'dbPath':
                    updateDbPath(message.path);
                    break;
                case 'requestMetadata':
                    const metadata = collectMetadata();
                    vscode.postMessage({
                        command: 'metadataResponse',
                        data: metadata
                    });
                    break;
                case 'metadataLoaded':
                    clearError();
                    displayMetadata(message.data);
                    const loadBtn = document.getElementById('load-btn');
                    if (loadBtn) loadBtn.disabled = false;
                    break;
                case 'saveSuccess':
                    vscode.postMessage({
                        command: 'alert',
                        text: 'Metadata saved successfully!'
                    });
                    break;
                case 'exportSuccess':
                    vscode.postMessage({
                        command: 'alert',
                        text: 'CSV files exported successfully!'
                    });
                    break;
                case 'error':
                    showError('Error: ' + message.error);
                    document.getElementById('load-btn').disabled = false;
                    break;
            }
        });


        // Initialize
        vscode.postMessage({ command: 'ready' });
    </script>
</body>
</html>
